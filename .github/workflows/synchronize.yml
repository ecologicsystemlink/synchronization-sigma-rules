name: Synchronize and Convert Rules

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  sync-rules:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout My Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12.3'
          cache: 'pip'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Install Sigma Backend Plugin
        run: |
          sigma plugin install golangexpr

      - name: Verify Tools Installation
        run: |
          sigma version
          python3 --version

      - name: Clone Source Repository
        uses: GuillaumeFalourd/clone-github-repo-action@v2.3
        with:
          owner: 'ecologicsystemlink'
          repository: 'sigma-simple'
          branch: 'main'
          
      - name: Move cloned repository
        run: |
          mv ${{ github.workspace }}/sigma-simple ${{ github.workspace }}/source-repo

      - name: Get last synchronized commit
        id: last-commit
        run: |
          cd ${{ github.workspace }}
          if [ -f ".last_synced_commit" ]; then
            echo "LAST_KNOWN_COMMIT=$(cat .last_synced_commit)" >> $GITHUB_OUTPUT
          else
            echo "LAST_KNOWN_COMMIT=" >> $GITHUB_OUTPUT
          fi

      - name: Find modified files
        id: diff
        run: |
          cd ${{ github.workspace }}/source-repo
          if [ -z "${{ steps.last-commit.outputs.LAST_KNOWN_COMMIT }}" ]; then
            echo "First execution, processing all files..."
            find . -name "*.yml" \( -path "*/rules/*" -o -path "*/rules-*/*" \) > ${{ github.workspace }}/modified_files.txt
          else
            echo "Looking for changes since ${{ steps.last-commit.outputs.LAST_KNOWN_COMMIT }}..."
            git diff --name-only ${{ steps.last-commit.outputs.LAST_KNOWN_COMMIT }} HEAD -- '*.yml' | grep -E '/(rules|rules-[^/]+)/' > ${{ github.workspace }}/modified_files.txt || true
          fi

      - name: Validate modified files
        id: modified-files
        run: |
          cd ${{ github.workspace }}
          if [ ! -f "modified_files.txt" ]; then
            echo "Error: modified_files.txt not found"
            exit 1
          fi
          
          if [ ! -s "modified_files.txt" ]; then
            echo "No modified files found, skipping conversion"
            echo "skip_conversion=true" >> $GITHUB_OUTPUT
          else
            echo "Found $(wc -l < modified_files.txt) files to process"
            echo "skip_conversion=false" >> $GITHUB_OUTPUT
          fi

      - name: Execute Conversion Script
        if: steps.modified-files.outputs.skip_conversion == 'false'
        run: |
          cd ${{ github.workspace }}
          echo "Starting conversion process..."
          if ! python convert_entry.py ${{ github.workspace }}/modified_files.txt; then
            echo "Error: Conversion script failed"
            exit 1
          fi
          echo "Conversion completed successfully"

      - name: Create batches and commit files
        if: steps.modified-files.outputs.skip_conversion == 'false'
        run: |
          cd ${{ github.workspace }}
          # Split input files into batches of 10
          split -l 10 modified_files.txt batch_
          echo "Batches created:"
          ls -la batch_*
          
          # Configure git
          git config --local user.name "${{ github.actor }}"
          git config --local user.email "${{ github.actor }}@users.noreply.github.com"
          
          batch_count=1
          total_batches=$(ls batch_* | wc -l)
          
          for batch_file in batch_*; do
            echo "Processing batch $batch_count of $total_batches..."
            
            # Add current batch files to staging
            files_added=0
            while read -r file; do
              # Remove leading ./ if present and convert to workspace path
              clean_file=$(echo "$file" | sed 's|^\./||')
              workspace_file="$clean_file"
              
              if [ -f "$workspace_file" ]; then
                git add "$workspace_file"
                files_added=$((files_added + 1))
              fi
            done < "$batch_file"
            
            # Create commit for this batch only if files were added
            if [ $files_added -gt 0 ]; then
              git commit -m "Batch $batch_count/$total_batches: Convert $files_added Sigma rules to UTMSTACK format" || echo "No changes in batch $batch_count"
              echo "Committed batch $batch_count with $files_added files"
            else
              echo "No files to commit in batch $batch_count"
            fi
            
            batch_count=$((batch_count + 1))
          done
            
          # Clean up batch files
          rm -f batch_*
            
          echo "All batches processed successfully"

      - name: Save new synchronization point
        run: |
          cd ${{ github.workspace }}/source-repo
          git rev-parse HEAD > ${{ github.workspace }}/.last_synced_commit
          cd ${{ github.workspace }}
          git add .last_synced_commit
          git commit -m "Update synchronization state" || echo "No state changes to commit"

      - name: Generate unique branch name
        id: branch
        if: steps.modified-files.outputs.skip_conversion == 'false'
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BRANCH_NAME="sync/automatic-update-${TIMESTAMP}"
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "Generated branch name: ${BRANCH_NAME}"

      - name: Create and push commits to new branch
        id: push-branch
        if: steps.modified-files.outputs.skip_conversion == 'false'
        run: |
          cd ${{ github.workspace }}
          echo "Creating branch: ${{ steps.branch.outputs.BRANCH_NAME }}"
          git checkout -b ${{ steps.branch.outputs.BRANCH_NAME }}
          git push origin ${{ steps.branch.outputs.BRANCH_NAME }}
          echo "Successfully pushed commits to branch"
          echo "should_create_pr=true" >> $GITHUB_OUTPUT
          echo "No changes to push, skipping branch creation"
          echo "should_create_pr=false" >> $GITHUB_OUTPUT

      - name: Create Pull Request
        if: steps.push-branch.outputs.should_create_pr == 'true'
        run: |
          cd ${{ github.workspace }}
          
          # Count commits in this branch vs main
          COMMIT_COUNT=$(git rev-list --count main..${{ steps.branch.outputs.BRANCH_NAME }})
          
          # Generate dynamic PR body with metadata
          TIMESTAMP=$(date '+%Y-%m-%d at %H:%M UTC')
          
          PR_BODY="**Automatic synchronization from source repository**

          **Execution Details:**
          - **Timestamp:** ${TIMESTAMP}
          - **Branch:** \`${{ steps.branch.outputs.BRANCH_NAME }}\`
          - **Commits:** ${COMMIT_COUNT} commits with batches of 10 files each
          - **Source commit:** \`${{ steps.last-commit.outputs.LAST_KNOWN_COMMIT || 'Initial sync' }}\`

          **Summary:**
          This PR contains converted Sigma rules organized in batches for easier review. Each commit represents a batch of up to 10 converted files.

          **Review Guide:**
          - Each commit can be reviewed independently
          - Files are organized by data source (antivirus, aws, cisco, etc.)
          - All rules follow UTMSTACK format standards

          ---
          _Generated automatically by GitHub Actions - Workflow run #${{ github.run_number }}_"
          
          gh pr create \
            --title "Sync: Sigma rules (${TIMESTAMP})" \
            --body "${PR_BODY}" \
            --base main \
            --head ${{ steps.branch.outputs.BRANCH_NAME }} \
            --label "automation,sigma-rules,sync" \
            --assignee "${{ github.actor }}"
          
          echo "Pull Request created successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
